[{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Quick Start","text":"areaOfEffect package classifies spatial points position relative region’s boundary—without requiring sf expertise. Dataframe → dataframe . Points classified : Core: inside original support Halo: outside original inside area effect Pruned: outside AoE entirely (removed) default, halos defined equal area core—proportion-based definition enables consistent cross-region comparisons.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"Quick Start","text":"","code":"library(areaOfEffect) library(sf) library(ggplot2)"},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"from-a-dataframe","dir":"Articles","previous_headings":"Getting Started","what":"From a Dataframe","title":"Quick Start","text":"simplest usage: pass dataframe coordinates country name. package auto-detects coordinate columns (lon/lat, x/y, longitude/latitude, etc.).","code":"# Your occurrence data observations <- data.frame(   species = c(\"Oak\", \"Beech\", \"Pine\", \"Spruce\"),   lon = c(14.5, 15.2, 16.8, 20.0),   lat = c(47.5, 48.1, 47.2, 48.5) )  # Classify relative to Austria result <- aoe(observations, \"Austria\") result$aoe_class #> [1] \"core\" \"core\" \"halo\""},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"from-sf-objects","dir":"Articles","previous_headings":"Getting Started","what":"From sf Objects","title":"Quick Start","text":"sf objects work directly:","code":"result <- aoe(pts_sf, \"AT\")"},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"austria-example","dir":"Articles","previous_headings":"","what":"Austria Example","title":"Quick Start","text":"Austria (dark) area effect (blue dashed). halo equal area core.","code":"# Get Austria and transform to equal-area projection austria <- get_country(\"AT\") austria_ea <- st_transform(austria, \"ESRI:54009\")  # Create a point inside Austria dummy_pt <- st_centroid(austria_ea) #> Warning: st_centroid assumes attributes are constant over geometries  # Run aoe() to get geometries (uses buffer method by default) result <- aoe(dummy_pt, austria_ea) geoms <- aoe_geometry(result, \"both\")  # Extract geometries austria_geom <- geoms[geoms$type == \"original\", ] aoe_geom <- geoms[geoms$type == \"aoe\", ]  # Plot with ggplot2 ggplot() +   geom_sf(data = aoe_geom, fill = aoe_colors$aoe_fill, color = aoe_colors$aoe_border,           linetype = \"dashed\", linewidth = 1) +   geom_sf(data = austria_geom, fill = NA, color = aoe_colors$support, linewidth = 1.2) +   labs(title = NULL) +   theme_aoe()"},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"basic-usage-with-custom-polygons","dir":"Articles","previous_headings":"","what":"Basic Usage with Custom Polygons","title":"Quick Start","text":"Create observation points: Apply area effect: result contains points inside AoE, classification:","code":"support <- st_as_sf(   data.frame(id = 1),   geometry = st_sfc(st_polygon(list(     cbind(c(0, 100, 100, 0, 0), c(0, 0, 100, 100, 0))   ))),   crs = 32631 ) pts <- st_as_sf(   data.frame(     id = 1:5,     value = c(10, 20, 15, 25, 30)   ),   geometry = st_sfc(     st_point(c(50, 50)),   # center     st_point(c(10, 10)),   # near corner     st_point(c(95, 50)),   # near edge     st_point(c(120, 50)),  # outside, in halo     st_point(c(250, 250))  # far outside   ),   crs = 32631 ) result <- aoe(pts, support) print(result) #> Area of Effect Result #> ───────────────────── #> Points:   4 (3 core, 1 halo) #> Supports: 1 #> Scale:    0.414 (multiplier 1.41, theoretical halo:core 1.00) #>  #> Simple feature collection with 4 features and 5 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 10 ymin: 10 xmax: 120 ymax: 50 #> Projected CRS: WGS 84 / UTM zone 31N #>   point_id support_id aoe_class id value       geometry #> 1        1          1      core  1    10  POINT (50 50) #> 2        2          1      core  2    20  POINT (10 10) #> 3        3          1      core  3    15  POINT (95 50) #> 4        4          1      halo  4    25 POINT (120 50) result$aoe_class #> [1] \"core\" \"core\" \"core\" \"halo\""},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"multiple-supports","dir":"Articles","previous_headings":"","what":"Multiple Supports","title":"Quick Start","text":"Process multiple regions : Points can appear multiple times (per support whose AoE contains ).","code":"# Two adjacent regions supports <- st_as_sf(   data.frame(region = c(\"A\", \"B\")),   geometry = st_sfc(     st_polygon(list(cbind(c(0, 50, 50, 0, 0), c(0, 0, 100, 100, 0)))),     st_polygon(list(cbind(c(50, 100, 100, 50, 50), c(0, 0, 100, 100, 0))))   ),   crs = 32631 )  # Points that may fall in overlapping AoEs pts_multi <- st_as_sf(   data.frame(id = 1:3),   geometry = st_sfc(     st_point(c(25, 50)),   # inside A     st_point(c(50, 50)),   # on boundary     st_point(c(75, 50))    # inside B   ),   crs = 32631 )  result_multi <- aoe(pts_multi, supports) print(result_multi) #> Area of Effect Result #> ───────────────────── #> Points:   4 (4 core, 0 halo) #> Supports: 2 #> Scale:    0.414 (multiplier 1.41, theoretical halo:core 1.00) #>  #> Simple feature collection with 4 features and 4 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 25 ymin: 50 xmax: 75 ymax: 50 #> Projected CRS: WGS 84 / UTM zone 31N #>   point_id support_id aoe_class id      geometry #> 1        1          1      core  1 POINT (25 50) #> 2        2          1      core  2 POINT (50 50) #> 3        2          2      core  2 POINT (50 50) #> 4        3          2      core  3 POINT (75 50)"},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"using-a-mask-coastlines","dir":"Articles","previous_headings":"","what":"Using a Mask (Coastlines)","title":"Quick Start","text":"coastal regions, sea hard boundary. Provide mask constrain AoE: AoE land mask. AoE clipped land boundary.","code":"# Create a coastal support support_coast <- st_as_sf(   data.frame(id = 1),   geometry = st_sfc(st_polygon(list(     cbind(c(40, 80, 80, 40, 40), c(20, 20, 60, 60, 20))   ))),   crs = 32631 )  # Create land mask (irregular coastline) land_mask <- st_as_sf(   data.frame(id = 1),   geometry = st_sfc(st_polygon(list(cbind(     c(0, 100, 100, 70, 50, 30, 0, 0),     c(0, 0, 50, 60, 55, 70, 60, 0)   )))),   crs = 32631 )  # Create sea area (inverse of land for visualization) sea_area <- st_as_sf(  data.frame(id = 1),  geometry = st_sfc(st_polygon(list(cbind(    c(-20, 120, 120, -20, -20),    c(-20, -20, 100, 100, -20)  )))),  crs = 32631 ) sea_area <- st_difference(sea_area, land_mask) #> Warning: attribute variables are assumed to be spatially constant throughout #> all geometries  # Create some points pts_coast <- st_as_sf(   data.frame(id = 1:4, class = c(\"core\", \"core\", \"halo\", \"pruned\")),   geometry = st_sfc(     st_point(c(60, 40)),  # core     st_point(c(50, 30)),  # core     st_point(c(30, 40)),  # halo (on land)     st_point(c(90, 70))   # would be halo but in sea   ),   crs = 32631 )  # Apply with mask result_coast <- aoe(pts_coast[1:3, ], support_coast, mask = land_mask)  # Get geometries for visualization aoe_masked <- aoe_geometry(result_coast, \"aoe\") support_geom <- aoe_geometry(result_coast, \"original\")  # Prepare point data for plotting result_coast$class <- result_coast$aoe_class pruned_pt <- pts_coast[4, ]  # Plot with ggplot2 ggplot() +   geom_sf(data = sea_area, fill = aoe_colors$sea, color = NA) +   geom_sf(data = land_mask, fill = aoe_colors$land, color = aoe_colors$mask, linewidth = 0.8) +   geom_sf(data = aoe_masked, fill = aoe_colors$aoe_fill, color = aoe_colors$aoe_border,           linetype = \"dashed\", linewidth = 1) +   geom_sf(data = support_geom, fill = NA, color = aoe_colors$support, linewidth = 1.2) +   geom_sf(data = result_coast, aes(color = class), size = 4) +   geom_sf(data = pruned_pt, color = aoe_colors$point_pruned, shape = 4, size = 4, stroke = 1.5) +   scale_color_manual(     values = c(\"core\" = aoe_colors$point_core, \"halo\" = aoe_colors$point_halo),     labels = c(\"Core\", \"Halo\")   ) +   annotate(\"text\", x = 90, y = 80, label = \"SEA\", color = aoe_colors$aoe_border,            fontface = \"bold\", size = 5) +   coord_sf(xlim = c(-10, 110), ylim = c(-10, 90)) +   labs(color = \"Class\") +   theme_aoe()"},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"real-world-example-portugal","dir":"Articles","previous_headings":"Using a Mask (Coastlines)","what":"Real-World Example: Portugal","title":"Quick Start","text":"package includes bundled country boundaries global land mask. Use mask = \"land\" clip AoE coastlines: Portugal land-masked AoE. halo extends Spain Atlantic. area = 1 parameter ensures halo equal land area core, even ocean masked . Without , coastline clipping reduce effective halo area.","code":"# Create a point inside Portugal (approximate center of mainland) dummy <- st_as_sf(   data.frame(id = 1),   geometry = st_sfc(st_point(c(-8, 39.5))),   crs = 4326 )  # Without mask result_no_mask <- aoe(dummy, \"PT\") #> Using largest polygon (96.8% of total area); 8 smaller polygon(s) dropped. Set largest_polygon = FALSE to include all. aoe_no_mask <- aoe_geometry(result_no_mask, \"aoe\")  # With mask + area=1 for equal land area result_masked <- aoe(dummy, \"PT\", mask = \"land\", area = 1) #> Using largest polygon (96.8% of total area); 8 smaller polygon(s) dropped. Set largest_polygon = FALSE to include all. aoe_masked <- aoe_geometry(result_masked, \"aoe\")  # Get support geometry support_geom <- aoe_geometry(result_masked, \"original\")  # Transform to equal area for plotting crs_ea <- st_crs(\"+proj=laea +lat_0=39.5 +lon_0=-8 +datum=WGS84\") aoe_no_mask_ea <- st_transform(aoe_no_mask, crs_ea) aoe_masked_ea <- st_transform(aoe_masked, crs_ea) support_ea <- st_transform(support_geom, crs_ea)  # Prepare legend data legend_data <- data.frame(   type = factor(c(\"Portugal\", \"AoE (unmasked)\", \"AoE (land only)\"),                 levels = c(\"Portugal\", \"AoE (unmasked)\", \"AoE (land only)\")) )  # Crop to focus on relevant area bbox <- st_bbox(aoe_no_mask_ea) y_range <- bbox[4] - bbox[2]  # Plot with ggplot2 ggplot() +   geom_sf(data = aoe_no_mask_ea, fill = NA, color = aoe_colors$mask,           linetype = \"dashed\", linewidth = 1) +   geom_sf(data = aoe_masked_ea, fill = aoe_colors$aoe_fill, color = aoe_colors$aoe_border,           linetype = \"dashed\", linewidth = 1) +   geom_sf(data = support_ea, fill = NA, color = aoe_colors$support, linewidth = 1.2) +   coord_sf(ylim = c(bbox[2] + y_range * 0.2, bbox[4])) +   theme_aoe()"},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"scale-parameter","dir":"Articles","previous_headings":"","what":"Scale Parameter","title":"Quick Start","text":"scale parameter controls halo size proportion core area.","code":"# Default: equal core/halo areas (scale = sqrt(2) - 1) result_default <- aoe(pts, support)  # Scale = 1: larger halo (3:1 area ratio) result_large <- aoe(pts, support, scale = 1)"},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"area-parameter-target-halo-area","dir":"Articles","previous_headings":"","what":"Area Parameter (Target Halo Area)","title":"Quick Start","text":"Sometimes need specific halo area regardless masking. area parameter specifies target halo area proportion original support: Unlike scale, area accounts masking: function finds scale produces target halo area mask intersection. useful coastal regions scale alone produce inconsistent effective areas.","code":"# Halo area = original area (same as scale = sqrt(2) - 1 without mask) result <- aoe(pts, support, area = 1)  # Halo area = half of original result <- aoe(pts, support, area = 0.5) # Target area = 1 means halo = original, even after coastline clipping result <- aoe(pts, support, area = 1, mask = \"land\")"},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"adaptive-expansion-with-aoe_expand","dir":"Articles","previous_headings":"","what":"Adaptive Expansion with aoe_expand()","title":"Quick Start","text":"supports points baseline AoE, aoe_expand() finds minimum scale needed capture target number points: Two safety caps prevent unreasonable expansion: max_area = 2 (default): halo area exceed 2× original max_dist: maximum expansion distance CRS units Check expansion details:","code":"# Create sparse data set.seed(42) pts_sparse <- st_as_sf(   data.frame(id = 1:15),   geometry = st_sfc(c(     lapply(1:5, function(i) st_point(c(runif(1, 20, 80), runif(1, 20, 80)))),     lapply(1:10, function(i) st_point(c(runif(1, -50, 150), runif(1, -50, 150))))   )),   crs = 32631 )  # Expand until at least 10 points are captured result_expand <- aoe_expand(pts_sparse, support, min_points = 10) # Strict caps result <- aoe_expand(pts, support,                      min_points = 50,                      max_area = 1.5,    # halo ≤ 1.5× original                      max_dist = 500)    # max 500m expansion info <- attr(result_expand, \"expansion_info\") info #>   support_id scale_used points_captured target_reached cap_hit #> 1          1  0.6412593              10           TRUE    none"},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"balanced-sampling-with-aoe_sample","dir":"Articles","previous_headings":"","what":"Balanced Sampling with aoe_sample()","title":"Quick Start","text":"Core regions often dominate due point density. aoe_sample() provides stratified sampling balance core/halo representation: Custom ratios fixed sample sizes: multiple supports, use = \"support\" sample within :","code":"# Create imbalanced data (many core, few halo) set.seed(42) pts_imbal <- st_as_sf(   data.frame(id = 1:60),   geometry = st_sfc(c(     lapply(1:50, function(i) st_point(c(runif(1, 10, 90), runif(1, 10, 90)))),     lapply(1:10, function(i) st_point(c(runif(1, 110, 140), runif(1, 10, 90))))   )),   crs = 32631 )  result_imbal <- aoe(pts_imbal, support, scale = 1)  # Default: balance core/halo (downsamples core to match halo) set.seed(123) balanced <- aoe_sample(result_imbal) table(balanced$aoe_class) #>  #> core halo  #>   10   10 # Fixed n with 70/30 split set.seed(123) sampled <- aoe_sample(result_imbal, n = 20, ratio = c(core = 0.7, halo = 0.3)) table(sampled$aoe_class) #>  #> core halo  #>   14    6 sampled <- aoe_sample(result_multi, by = \"support\")"},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"border-classification-with-aoe_border","dir":"Articles","previous_headings":"","what":"Border Classification with aoe_border()","title":"Quick Start","text":"study involves boundary line rather polygon (e.g., river, mountain range, political border), use aoe_border() classify points distance side border. Border classification. Points classified side (blue vs orange) distance (core vs halo) border line. aoe_border() function: Creates symmetric buffer zones sides border Classifies points “core” (near border) “halo” (farther away) Assigns point side based position relative line","code":"# Create a diagonal border line border_line <- st_as_sf(   data.frame(id = 1),   geometry = st_sfc(st_linestring(matrix(     c(0, 0,       100, 100), ncol = 2, byrow = TRUE   ))),   crs = 32631 )  # Create points on both sides set.seed(42) pts_border <- st_as_sf(   data.frame(id = 1:30),   geometry = st_sfc(c(     # Points on side 1 (above the line)     lapply(1:15, function(i) st_point(c(runif(1, 10, 90), runif(1, 10, 90) + 20))),     # Points on side 2 (below the line)     lapply(1:15, function(i) st_point(c(runif(1, 10, 90), runif(1, 10, 90) - 20)))   )),   crs = 32631 )  # Classify by distance from border result_border <- aoe_border(   pts_border, border_line,   width = 30,   side_names = c(\"north\", \"south\") )  # Extract geometries for ggplot2 geoms <- attr(result_border, \"border_geometries\")  # Plot with ggplot2 ggplot() +   # Halo zones (background)   geom_sf(data = geoms$side1_halo, fill = paste0(aoe_colors$side_a, \"20\"), color = NA) +   geom_sf(data = geoms$side2_halo, fill = paste0(aoe_colors$side_b, \"20\"), color = NA) +   # Core zones   geom_sf(data = geoms$side1_core, fill = paste0(aoe_colors$side_a, \"40\"), color = NA) +   geom_sf(data = geoms$side2_core, fill = paste0(aoe_colors$side_b, \"40\"), color = NA) +   # Border line   geom_sf(data = geoms$border, color = aoe_colors$support, linewidth = 1.5) +   # Points   geom_sf(data = result_border,           aes(color = side, shape = aoe_class), size = 3) +   scale_color_manual(values = c(\"north\" = aoe_colors$side_a, \"south\" = aoe_colors$side_b)) +   scale_shape_manual(values = c(\"core\" = 16, \"halo\" = 1),                      labels = c(\"Core\", \"Halo\")) +   labs(color = \"Side\", shape = \"Class\") +   theme_aoe()"},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"area-based-border-zones","dir":"Articles","previous_headings":"Border Classification with aoe_border()","what":"Area-Based Border Zones","title":"Quick Start","text":"Use area parameter specify target zone areas instead fixed widths:","code":"# Each side's core zone has area 5000 (in CRS units²) result <- aoe_border(pts, border, area = 5000)"},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"sampling-from-border-results","dir":"Articles","previous_headings":"Border Classification with aoe_border()","what":"Sampling from Border Results","title":"Quick Start","text":"aoe_sample() also works border results, allowing stratification side class:","code":"# Balance by side (equal north/south) set.seed(123) balanced_side <- aoe_sample(result_border, ratio = c(north = 0.5, south = 0.5)) table(balanced_side$side) #>  #> north south  #>    12    12  # Balance by distance class set.seed(123) balanced_class <- aoe_sample(result_border, by = \"class\") table(balanced_class$aoe_class) #>  #> core halo  #>   11   11"},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"diagnostics","dir":"Articles","previous_headings":"","what":"Diagnostics","title":"Quick Start","text":"","code":"aoe_summary(result) #>   support_id n_total n_core n_halo prop_core prop_halo #> 1          1       4      3      1      0.75      0.25"},{"path":"https://gcol33.github.io/areaOfEffect/articles/quickstart.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Quick Start","text":"aoe() classifies points “core” “halo” Works dataframes sf objects Pass country codes directly: aoe(df, \"\") Area-based halos enable consistent cross-country comparisons Use mask coastlines hard boundaries Use area parameter target halo area (accounts masking) Use aoe_expand() adaptive expansion capture minimum points Use aoe_sample() balanced core/halo sampling Use aoe_border() border/line-based classification Use aoe_summary() diagnostics","code":""},{"path":"https://gcol33.github.io/areaOfEffect/articles/theory.html","id":"what-aoe-is-not","dir":"Articles","previous_headings":"","what":"What AoE is Not","title":"Theory","text":"explaining AoE , ’s important clarify : buffer: Buffers add fixed distance. AoE computes buffer distance area target—specify much area, many meters. distance decay: continuous weight function. Points categorically classified core, halo, pruned. magic number: default scale (√2 − 1) derived constraint equal core/halo areas, chosen arbitrarily. can override domain knowledge.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/articles/theory.html","id":"the-problem-border-truncation","dir":"Articles","previous_headings":"","what":"The Problem: Border Truncation","title":"Theory","text":"analyzing spatial data within political administrative boundaries, fundamental assumption often violated: sampling region represents ecological extent processes studied. Consider sampling species occurrences within country. Observations near border influenced conditions outside country. forest spans border, river crosses , simply continuous nature climate habitat means truncating border introduces systematic bias. border truncation: artificial constraint ecological processes administrative boundaries.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/articles/theory.html","id":"the-area-of-effect","dir":"Articles","previous_headings":"","what":"The Area of Effect","title":"Theory","text":"area effect (AoE) spatial extent observations within support influenced external conditions. computed expanding support boundary outward create halo region. key insight: halos defined proportion region area, arbitrary buffer distances. enables consistent cross-region comparisons without units scale dependencies.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/articles/theory.html","id":"core-and-halo-classification","dir":"Articles","previous_headings":"","what":"Core and Halo Classification","title":"Theory","text":"Points within AoE classified two categories: Core: Points inside original support. fully contained within sampling region represent “pure” observations unaffected border effects. Halo: Points outside original support inside expanded AoE. observations influenced conditions border zone may require different treatment analysis. Points outside AoE pruned (removed). distant meaningfully related support region. Point classification AoE. Core points (green) inside original support. Halo points (orange) expanded region. Points outside AoE pruned.","code":"#> Linking to GEOS 3.13.1, GDAL 3.11.4, PROJ 9.7.0; sf_use_s2() is TRUE"},{"path":"https://gcol33.github.io/areaOfEffect/articles/theory.html","id":"the-scale-parameter","dir":"Articles","previous_headings":"","what":"The Scale Parameter","title":"Theory","text":"scale parameter controls large halo relative core. relationship scale area : Total AoE area=Core area×(1+s)2\\text{Total AoE area} = \\text{Core area} \\times (1 + s)^2 ss scale parameter. Two values special meaning: sqrt(2) - 1 ≈ 0.414 (default): Equal core halo areas 1: Halo area 3× core area","code":""},{"path":"https://gcol33.github.io/areaOfEffect/articles/theory.html","id":"why-equal-area-is-the-default","dir":"Articles","previous_headings":"","what":"Why Equal Area is the Default","title":"Theory","text":"default scale produces equal core halo areas. arbitrary—reflects principled position spatial influence.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/articles/theory.html","id":"the-symmetry-argument","dir":"Articles","previous_headings":"Why Equal Area is the Default","what":"The Symmetry Argument","title":"Theory","text":"say point halo “influenced ” support region, ’re making claim spatial relevance. question : much relevance grant outside? Equal area says: outside matters much inside. maximally symmetric choice. ratio implies either: core important halo (halo smaller), External conditions dominate internal ones (halo larger) Without domain-specific knowledge justify asymmetry, equal weighting principled default.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/articles/theory.html","id":"the-information-theoretic-view","dir":"Articles","previous_headings":"Why Equal Area is the Default","what":"The Information-Theoretic View","title":"Theory","text":"Consider AoE defining probability distribution space: “might conditions relevant support come ?” Equal areas means equal prior probability mass inside outside original boundary. maximum-entropy choice—encodes bias toward internal external dominance.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/articles/theory.html","id":"the-geometric-inevitability","dir":"Articles","previous_headings":"Why Equal Area is the Default","what":"The Geometric Inevitability","title":"Theory","text":"formula s=2−1s = \\sqrt{2} - 1 tuned parameter. ’s unique solution constraint “core equals halo”: (1+s)2−1=1⟹s=2−1 (1 + s)^2 - 1 = 1 \\implies s = \\sqrt{2} - 1 ’s something satisfying default isn’t chosen derived. removes degree freedom analyst replaces principled constraint.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/articles/theory.html","id":"when-to-override","dir":"Articles","previous_headings":"Why Equal Area is the Default","what":"When to Override","title":"Theory","text":"Use scale = 1 : domain knowledge suggests external conditions strongly dominate ’re comparing previous work used convention Use custom scales : empirical data influence decay Sensitivity analysis requires exploring parameter space Domain expertise justifies specific ratio","code":""},{"path":"https://gcol33.github.io/areaOfEffect/articles/theory.html","id":"method-buffer-vs-stamp","dir":"Articles","previous_headings":"","what":"Method: Buffer vs Stamp","title":"Theory","text":"package offers two methods computing AoE:","code":""},{"path":"https://gcol33.github.io/areaOfEffect/articles/theory.html","id":"buffer-method-default","dir":"Articles","previous_headings":"Method: Buffer vs Stamp","what":"Buffer Method (Default)","title":"Theory","text":"buffer method expands boundary uniformly directions. buffer distance computed achieve target halo area. Advantages: Robust polygon shape Always guarantees AoE contains original support Consistent behavior concave shapes works: buffer distance dd found solving: πd2+P⋅d=Ahalo\\pi d^2 + P \\cdot d = A_{\\text{halo}} PP perimeter AhaloA_{\\text{halo}} target halo area.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/articles/theory.html","id":"stamp-method-alternative","dir":"Articles","previous_headings":"Method: Buffer vs Stamp","what":"Stamp Method (Alternative)","title":"Theory","text":"stamp method scales vertices outward centroid, preserving shape proportions. Advantages: Preserves shape’s proportions Exact area calculation Limitation: guarantees containment star-shaped polygons (centroid can “see” boundary points). highly concave shapes like country boundaries, small gaps may occur original fully contained. Use method = \"stamp\" working convex nearly convex regions shape preservation important.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/articles/theory.html","id":"hard-vs-soft-boundaries","dir":"Articles","previous_headings":"","what":"Hard vs Soft Boundaries","title":"Theory","text":"AoE distinguishes two types boundaries: Political borders (soft): Administrative lines ecological meaning. AoE freely crosses . country border stop species dispersing climate varying. Sea boundaries (hard): Physical barriers like coastlines true boundaries. optional mask argument enforces constraints intersecting AoE land polygon. Hard boundaries constrain AoE. dashed line shows theoretical AoE; gray area shows AoE applying land mask.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/articles/theory.html","id":"multiple-supports","dir":"Articles","previous_headings":"","what":"Multiple Supports","title":"Theory","text":"Real-world analyses often involve multiple administrative regions (countries, provinces, protected areas). AoE handles naturally: support processed independently Points can fall within multiple AoEs (regions adjacent) Output long format: one row per point-support combination enables cross-border analyses studies nested administrative structures without repeated preprocessing.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/articles/theory.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Theory","text":"area effect provides principled correction border truncation spatial analysis: Area-based definition: Halos defined proportion region area, arbitrary distances Principled default: Scale = √2 − 1, giving equal core halo areas Geometric derivation: default emerges symmetry, tuning Robust method: Buffer-based expansion works polygon shape Categorical output: Core, halo, pruned Soft/hard boundaries: Political borders ignored, physical barriers respected Multiple supports: Process many regions result reproducible, interpretable method can consistently applied across studies.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Gilles Colling. Author, maintainer, copyright holder.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Colling G (2026). areaOfEffect: Classify Points Distance Polygon Boundaries. R package version 0.2.5, https://gillescolling.com/areaOfEffect/.","code":"@Manual{,   title = {areaOfEffect: Classify Points by Distance to Polygon Boundaries},   author = {Gilles Colling},   year = {2026},   note = {R package version 0.2.5},   url = {https://gillescolling.com/areaOfEffect/}, }"},{"path":"https://gcol33.github.io/areaOfEffect/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"CLAUDE.md","title":"CLAUDE.md","text":"file provides guidance Claude Code (claude.ai/code) working code repository.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/CLAUDE.html","id":"package-overview","dir":"","previous_headings":"","what":"Package Overview","title":"CLAUDE.md","text":"areaOfEffect R package spatial support classification ecological analysis. classifies occurrence points “core” (inside original support polygon) “halo” (inside expanded area effect outside original), pruning points outside . default expansion produces equal core halo areas.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/CLAUDE.html","id":"development-commands","dir":"","previous_headings":"","what":"Development Commands","title":"CLAUDE.md","text":"","code":"# Run tests \"C:\\Program Files\\R\\R-4.5.2\\bin\\Rscript.exe\" -e \"testthat::test_local()\"  # Run single test file \"C:\\Program Files\\R\\R-4.5.2\\bin\\Rscript.exe\" -e \"testthat::test_file('tests/testthat/test-aoe.R')\"  # Check package (R CMD check equivalent) \"C:\\Program Files\\R\\R-4.5.2\\bin\\Rscript.exe\" -e \"devtools::check()\"  # Build documentation (roxygen2) \"C:\\Program Files\\R\\R-4.5.2\\bin\\Rscript.exe\" -e \"devtools::document()\"  # Install package locally \"C:\\Program Files\\R\\R-4.5.2\\bin\\Rscript.exe\" -e \"devtools::install()\"  # Build pkgdown site \"C:\\Program Files\\R\\R-4.5.2\\bin\\Rscript.exe\" -e \"source('~/.R/build_pkgdown.R'); build_pkgdown_site()\""},{"path":[]},{"path":"https://gcol33.github.io/areaOfEffect/CLAUDE.html","id":"core-functions-r","dir":"","previous_headings":"Architecture","what":"Core Functions (R/)","title":"CLAUDE.md","text":"aoe.R: Main aoe() function - classifies points relative support polygons Supports country names/codes (uses bundled countries data) custom sf polygons Two expansion methods: buffer (uniform boundary expansion) stamp (vertex scaling centroid) scale parameter controls halo size; area parameter finds scale achieving target masked halo area mask parameter clips expansion (e.g., mask = \"land\" clips coastlines) aoe_border.R: aoe_border() - classifies points distance line (border) Creates symmetric buffer zones sides Returns aoe_border_result S3 class side core/halo classification aoe_class.R: S3 class infrastructure aoe_result print, summary, plot, [ methods Stores geometries attributes later extraction aoe_geometry.R: aoe_geometry() - extracts support/AoE polygons results aoe_area.R: aoe_area() - area diagnostics (original, raw AoE, masked AoE) aoe_expand.R: aoe_expand() - expand geometries without point classification aoe_sample.R: aoe_sample() - stratified sampling results (support, class, side) aoe_summary.R: aoe_summary() - point counts support class","code":""},{"path":"https://gcol33.github.io/areaOfEffect/CLAUDE.html","id":"bundled-data-data","dir":"","previous_headings":"Architecture","what":"Bundled Data (data/)","title":"CLAUDE.md","text":"countries.rda: Country boundaries (sf) lookup name ISO code land.rda: Global land polygon coastline masking country_halos.rda: Pre-computed country halos","code":""},{"path":"https://gcol33.github.io/areaOfEffect/CLAUDE.html","id":"key-dependencies","dir":"","previous_headings":"Architecture","what":"Key Dependencies","title":"CLAUDE.md","text":"sf: spatial operations (required) lwgeom: Optional, used st_split() border splitting (fallback exists)","code":""},{"path":[]},{"path":"https://gcol33.github.io/areaOfEffect/CLAUDE.html","id":"geometry-expansion","dir":"","previous_headings":"Code Patterns","what":"Geometry Expansion","title":"CLAUDE.md","text":"Buffer method solves distance d π*d² + P*d = A_target (perimeter formula), binary searches exact fit. Stamp method applies affine transformation: p' = r + (1+scale)(p - r) reference point.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/CLAUDE.html","id":"area-mode-vs-scale-mode","dir":"","previous_headings":"Code Patterns","what":"Area Mode vs Scale Mode","title":"CLAUDE.md","text":"scale parameter: direct geometric scaling (halo area = original × ((1+scale)² - 1)) area parameter: finds scale produces target halo area mask intersection, using secant method","code":""},{"path":"https://gcol33.github.io/areaOfEffect/CLAUDE.html","id":"s3-classes","dir":"","previous_headings":"Code Patterns","what":"S3 Classes","title":"CLAUDE.md","text":"aoe_result: Extends sf, stores geometries aoe_geometries attribute aoe_border_result: Extends sf, stores border/zone geometries border_geometries attribute preserve attributes subsetting via custom [ methods","code":""},{"path":"https://gcol33.github.io/areaOfEffect/index.html","id":"areaofeffect","dir":"","previous_headings":"","what":"Classify Points by Distance to Polygon Boundaries","title":"Classify Points by Distance to Polygon Boundaries","text":"Classify Points Distance Polygon Boundaries areaOfEffect package classifies spatial points relative polygon boundaries, labeling point core (inside), halo (buffer zone), pruning (far). handles projection, buffering, point--polygon operations automatically. Pass dataframe country name sf polygon, get classified points back.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"Classify Points by Distance to Polygon Boundaries","text":"","code":"library(areaOfEffect)  # Your point data observations <- data.frame(   id = c(\"A\", \"B\", \"C\", \"D\"),   lon = c(14.5, 15.2, 16.8, 20.0),   lat = c(47.5, 48.1, 47.2, 48.5) )  # Classify relative to Austria result <- aoe(observations, \"Austria\") result$aoe_class #> [1] \"core\" \"core\" \"halo\" # (point D pruned - outside buffer zone)"},{"path":"https://gcol33.github.io/areaOfEffect/index.html","id":"statement-of-need","dir":"","previous_headings":"","what":"Statement of Need","title":"Classify Points by Distance to Polygon Boundaries","text":"Classifying points position relative polygon boundaries common spatial task: customers inside vs. near service area, sensors fall within vs. outside study region, events occurred inside vs. near border. underlying sf operations straightforward repetitive: load boundaries, handle CRS, compute buffers, run intersections. package wraps boilerplate single function. also solves less obvious problem: buffer distance use? 10km buffer means something different Luxembourg Brazil. default, areaOfEffect computes buffer produces equal core halo areas, giving scale-independent definition “near boundary.” coastal irregular regions, buffer can extend areas don’t care (ocean, neighboring countries). mask parameter clips halo relevant areas, area parameter adjusts buffer achieve target area masking.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Classify Points by Distance to Polygon Boundaries","text":"Dataframes sf objects: pass either, get classified results back Bundled country boundaries: just pass \"Austria\" \"\", need find shapefiles Border classification: aoe_border() classifies points distance line (e.g., international borders) Coordinate column detection (handles lon/long/longitude/x, etc.) Equal-area projection accurate buffering Area-proportional buffer calculation Point--polygon classification Coastline masking (optional, bundled land polygon)","code":""},{"path":"https://gcol33.github.io/areaOfEffect/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Classify Points by Distance to Polygon Boundaries","text":"","code":"# Install from CRAN install.packages(\"areaOfEffect\")  # Or install development version from GitHub # install.packages(\"pak\") pak::pak(\"gcol33/areaOfEffect\")"},{"path":[]},{"path":"https://gcol33.github.io/areaOfEffect/index.html","id":"from-a-dataframe","dir":"","previous_headings":"Usage","what":"From a Dataframe","title":"Classify Points by Distance to Polygon Boundaries","text":"","code":"library(areaOfEffect)  # Plain dataframe with coordinates df <- data.frame(   id = 1:4,   longitude = c(14.5, 15.2, 16.8, 20.0),   latitude = c(47.5, 48.1, 47.2, 48.5) )  # Classify relative to Austria result <- aoe(df, \"Austria\")"},{"path":"https://gcol33.github.io/areaOfEffect/index.html","id":"from-sf-objects","dir":"","previous_headings":"Usage","what":"From sf Objects","title":"Classify Points by Distance to Polygon Boundaries","text":"","code":"library(sf)  # sf points work too pts_sf <- st_as_sf(df, coords = c(\"longitude\", \"latitude\"), crs = 4326) result <- aoe(pts_sf, \"AT\")"},{"path":"https://gcol33.github.io/areaOfEffect/index.html","id":"custom-polygons","dir":"","previous_headings":"Usage","what":"Custom Polygons","title":"Classify Points by Distance to Polygon Boundaries","text":"","code":"# Use your own sf polygon instead of country names my_region <- st_read(\"my_study_area.shp\") result <- aoe(df, my_region)"},{"path":"https://gcol33.github.io/areaOfEffect/index.html","id":"multiple-countries","dir":"","previous_headings":"Usage","what":"Multiple Countries","title":"Classify Points by Distance to Polygon Boundaries","text":"","code":"# Austria + Germany result <- aoe(df, c(\"AT\", \"DE\"))  # Auto-detect countries from points result <- aoe(df)"},{"path":"https://gcol33.github.io/areaOfEffect/index.html","id":"coastline-masking","dir":"","previous_headings":"Usage","what":"Coastline Masking","title":"Classify Points by Distance to Polygon Boundaries","text":"coastal countries, buffer (scaled equal area default) extends sea. ’re working terrestrial data, ’s useless area. mask parameter clips halo land:  area parameter finds buffer size gives target halo area clipping. area = 1 guarantees equal land area core halo, even countries like Japan half buffer otherwise ocean.","code":"# Use the bundled Natural Earth land polygon result <- aoe(df, \"Portugal\", mask = \"land\")  # Or bring your own mask result <- aoe(df, \"Portugal\", mask = my_land_polygon) # Equal land area, not equal total area result <- aoe(df, \"Japan\", mask = \"land\", area = 1)"},{"path":"https://gcol33.github.io/areaOfEffect/index.html","id":"scale","dir":"","previous_headings":"","what":"Scale","title":"Classify Points by Distance to Polygon Boundaries","text":"scale parameter controls halo size proportion core area. Default: sqrt(2) - 1 ≈ 0.414, gives equal core halo areas.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Classify Points by Distance to Polygon Boundaries","text":"Quick Start Vignette Function Reference","code":""},{"path":"https://gcol33.github.io/areaOfEffect/index.html","id":"support","dir":"","previous_headings":"","what":"Support","title":"Classify Points by Distance to Polygon Boundaries","text":"“Software like sex: ’s better ’s free.” — Linus Torvalds ’m PhD student builds R packages free time believe good tools free open. started projects work figured others might find useful . package saved time, buying coffee nice way say thanks. helps coffee addiction.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Classify Points by Distance to Polygon Boundaries","text":"MIT","code":""},{"path":"https://gcol33.github.io/areaOfEffect/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Classify Points by Distance to Polygon Boundaries","text":"","code":"@software{areaOfEffect,   author = {Colling, Gilles},   title = {areaOfEffect: Classify Points by Distance to Polygon Boundaries},   year = {2025},   url = {https://CRAN.R-project.org/package=areaOfEffect},   doi = {10.32614/CRAN.package.areaOfEffect} }"},{"path":"https://gcol33.github.io/areaOfEffect/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2026 Gilles Colling Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe.html","id":null,"dir":"Reference","previous_headings":"","what":"Classify and Prune Points by Area of Effect — aoe","title":"Classify and Prune Points by Area of Effect — aoe","text":"Given set points one support polygons, aoe() classifies points \"core\" (inside original support) \"halo\" (inside area effect outside original support), pruning points outside.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classify and Prune Points by Area of Effect — aoe","text":"","code":"aoe(   points,   support = NULL,   scale = NULL,   area = NULL,   method = c(\"buffer\", \"stamp\"),   reference = NULL,   mask = NULL,   largest_polygon = TRUE,   coords = NULL )"},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classify and Prune Points by Area of Effect — aoe","text":"points sf object POINT geometries. support One : sf object POLYGON/MULTIPOLYGON geometries Country name ISO code: \"France\", \"FR\", \"FRA\" Vector countries: c(\"France\", \"Germany\") Missing: auto-detects countries containing points scale Numeric scale factor (default sqrt(2) - 1, approximately 0.414). Controls size halo relative core: sqrt(2) - 1 (default): equal core/halo areas, ratio 1:1 1: area ratio 1:3 (halo 3x core area) method = \"buffer\", determines target halo area original_area * ((1 + scale)^2 - 1). method = \"stamp\", multiplier 1 + scale applied distances reference point. used together area. area Numeric area proportion (alternative scale). Specifies target halo area proportion original support area. example, area = 1 means halo area equals original support area. Unlike scale, parameter accounts masking: function finds scale produces target halo area mask intersection. useful need specific effective area regardless much gets clipped coastlines borders. used together scale. method Method computing area effect: \"buffer\" (default): Uniform buffer around support boundary. Robust polygon shape. Buffer distance calculated achieve target halo area. \"stamp\": Scale vertices outward centroid (reference point). Preserves shape proportions guarantees containment star-shaped polygons. May leave small gaps highly concave shapes. reference Optional sf object single POINT geometry. NULL (default), centroid support used. valid support single row method = \"stamp\". mask Optional mask clipping area effect. Can : sf object POLYGON MULTIPOLYGON geometry \"land\": use bundled global land mask exclude sea areas provided, area effect intersected mask. largest_polygon Logical (default TRUE). support contains multiple polygons (e.g., mainland plus islands), use largest polygon area. typically mainland. Points near dropped polygons pruned entirely (classified). Set FALSE include polygons, case area = \"equal\" uses total area redistribution across polygons. coords Column names coordinates points data.frame, e.g. c(\"lon\", \"lat\"). NULL, auto-detects common names.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classify and Prune Points by Area of Effect — aoe","text":"aoe_result object (extends sf) containing supported points, columns: point_id Original point identifier (row name index) support_id Identifier support classification refers aoe_class Classification: \"core\" \"halo\" multiple supports provided, points may appear multiple times (per support whose AoE contains ). result S3 methods print(), summary(), plot(). Use aoe_geometry() extract AoE polygons.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Classify and Prune Points by Area of Effect — aoe","text":"default, area effect computed using buffer produces equal core halo areas. means AoE twice area original support, split evenly core (inside) halo (outside).","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe.html","id":"buffer-method-default-","dir":"Reference","previous_headings":"","what":"Buffer method (default)","title":"Classify and Prune Points by Area of Effect — aoe","text":"Computes uniform buffer distance \\(d\\) buffered area equals target. buffer distance found solving: $$\\pi d^2 + P \\cdot d = A_{target}$$ \\(P\\) perimeter \\(A_{target}\\) desired halo area.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe.html","id":"stamp-method","dir":"Reference","previous_headings":"","what":"Stamp method","title":"Classify and Prune Points by Area of Effect — aoe","text":"Applies affine transformation vertex: $$p' = r + (1 + s)(p - r)$$ \\(r\\) reference point (centroid), \\(p\\) vertex, \\(s\\) scale factor. method preserves shape proportions guarantees AoE contains original star-shaped polygons (centroid can \"see\" boundary points). Points exactly original support boundary classified \"core\". support geometry validated internally using sf::st_make_valid().","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Classify and Prune Points by Area of Effect — aoe","text":"","code":"library(sf)  # Single support support <- st_as_sf(   data.frame(id = 1),   geometry = st_sfc(st_polygon(list(     cbind(c(0, 10, 10, 0, 0), c(0, 0, 10, 10, 0))   ))),   crs = 32631 )  pts <- st_as_sf(   data.frame(id = 1:4),   geometry = st_sfc(     st_point(c(5, 5)),     st_point(c(2, 2)),     st_point(c(15, 5)),     st_point(c(30, 30))   ),   crs = 32631 )  result <- aoe(pts, support)  # Multiple supports (e.g., admin regions) supports <- st_as_sf(   data.frame(region = c(\"A\", \"B\")),   geometry = st_sfc(     st_polygon(list(cbind(c(0, 10, 10, 0, 0), c(0, 0, 10, 10, 0)))),     st_polygon(list(cbind(c(8, 18, 18, 8, 8), c(0, 0, 10, 10, 0))))   ),   crs = 32631 )  result <- aoe(pts, supports) # Points near the boundary may appear in both regions' AoE"},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_area.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Area Statistics for AoE — aoe_area","title":"Compute Area Statistics for AoE — aoe_area","text":"Calculate area statistics original supports areas effect, including expansion ratios, masking effects, core/halo balance.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_area.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Area Statistics for AoE — aoe_area","text":"","code":"aoe_area(x)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_area.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Area Statistics for AoE — aoe_area","text":"x aoe_result object returned aoe().","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_area.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Area Statistics for AoE — aoe_area","text":"aoe_area_result data frame one row per support: support_id Support identifier area_core Area core region (original support) area_halo Area halo region (AoE minus core, masking) area_aoe Total AoE area masking halo_core_ratio Ratio halo core area (theoretically 3.0 without mask) pct_masked Percentage theoretical AoE area removed masking","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_area.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Area Statistics for AoE — aoe_area","text":"scale \\(s\\), AoE expands multiplier \\((1+s)\\) centroid, resulting \\((1+s)^2\\) times area. theoretical halo:core ratio \\((1+s)^2 - 1\\): Scale 1 (default): ratio 3.0 (core 1 part, halo 3 parts) Scale 0.414: ratio 1.0 (equal areas) Masking reduces halo (thus ratio) AoE extends beyond hard boundaries.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_area.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Area Statistics for AoE — aoe_area","text":"","code":"library(sf)  support <- st_as_sf(   data.frame(id = 1),   geometry = st_sfc(st_polygon(list(     cbind(c(0, 10, 10, 0, 0), c(0, 0, 10, 10, 0))   ))),   crs = 32631 )  pts <- st_as_sf(   data.frame(id = 1:3),   geometry = st_sfc(     st_point(c(5, 5)),     st_point(c(15, 5)),     st_point(c(2, 2))   ),   crs = 32631 )  result <- aoe(pts, support) aoe_area(result)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_border.html","id":null,"dir":"Reference","previous_headings":"","what":"Classify Points by Distance from a Border — aoe_border","title":"Classify Points by Distance from a Border — aoe_border","text":"Given set points border (line), aoe_border() classifies points side relative border distance . Creates equal-area buffer zones sides border.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_border.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classify Points by Distance from a Border — aoe_border","text":"","code":"aoe_border(   points,   border,   width = NULL,   area = NULL,   halo_width = NULL,   halo_area = NULL,   mask = NULL,   bbox = NULL,   side_names = c(\"side_1\", \"side_2\"),   coords = NULL )"},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_border.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classify Points by Distance from a Border — aoe_border","text":"points sf object POINT geometries, data.frame coordinate columns. border sf object LINESTRING MULTILINESTRING geometry representing border. width Buffer width meters (projected CRS) degrees (geographic CRS). Creates core zone within distance border. used together area. area Target area side's core zone. function finds buffer width produces area per side. mask provided, width adjusted achieve target area masking. used together width. halo_width Width halo zone beyond core. NULL (default), equals core width symmetric zones. halo_area Target area side's halo zone. Alternative halo_width. NULL halo_width NULL, defaults equal area core. mask Optional mask clipping buffer zones. Can : sf object POLYGON MULTIPOLYGON geometry \"land\": use bundled global land mask exclude sea areas bbox Optional bounding box limit study area. Can : sf sfc object (uses bounding box) Named vector: c(xmin = ..., ymin = ..., xmax = ..., ymax = ...) NULL: bbox restriction (uses buffer extent) side_names Character vector length 2 naming sides. Default c(\"side_1\", \"side_2\"). first name assigned left side border (traversing start end). coords Column names coordinates points data.frame.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_border.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classify Points by Distance from a Border — aoe_border","text":"aoe_border_result object (extends sf) containing classified points columns: point_id Original point identifier side side border: value side_names aoe_class Distance class: \"core\" \"halo\" Points outside study area pruned (returned).","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_border.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Classify Points by Distance from a Border — aoe_border","text":"function creates symmetric buffer zones around border line: Core zone: Points within width (area) distance border Halo zone: Points beyond core within width + halo_width Pruned: Points outside halo zone (returned) zone split border line determine side point falls .","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_border.html","id":"equal-area-across-sides","dir":"Reference","previous_headings":"","what":"Equal area across sides","title":"Classify Points by Distance from a Border — aoe_border","text":"using area parameter, buffer width calculated produce equal area sides border. masking, width adjusted masked area side equals target.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_border.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Classify Points by Distance from a Border — aoe_border","text":"","code":"library(sf)  # Create a border line border <- st_as_sf(   data.frame(id = 1),   geometry = st_sfc(st_linestring(matrix(     c(0, 0, 100, 100), ncol = 2, byrow = TRUE   ))),   crs = 32631 )  # Create points pts <- st_as_sf(   data.frame(id = 1:6),   geometry = st_sfc(     st_point(c(10, 20)),   # near border, side 1     st_point(c(30, 10)),   # near border, side 2     st_point(c(50, 80)),   # far from border, side 1     st_point(c(80, 40)),   # far from border, side 2     st_point(c(5, 5)),     # very close to border     st_point(c(200, 200))  # outside study area   ),   crs = 32631 )  # Classify by distance from border result <- aoe_border(pts, border, width = 20)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_expand.html","id":null,"dir":"Reference","previous_headings":"","what":"Adaptive AoE Expansion to Capture Minimum Points — aoe_expand","title":"Adaptive AoE Expansion to Capture Minimum Points — aoe_expand","text":"Expands area effect just enough capture least min_points, subject hard caps expansion. useful fixed scale leaves supports insufficient data stable modelling.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_expand.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adaptive AoE Expansion to Capture Minimum Points — aoe_expand","text":"","code":"aoe_expand(   points,   support = NULL,   min_points,   max_area = 2,   max_dist = NULL,   method = c(\"buffer\", \"stamp\"),   reference = NULL,   mask = NULL,   coords = NULL )"},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_expand.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adaptive AoE Expansion to Capture Minimum Points — aoe_expand","text":"points sf object POINT geometries. support One : sf object POLYGON/MULTIPOLYGON geometries Country name ISO code: \"France\", \"FR\", \"FRA\" Vector countries: c(\"France\", \"Germany\") Missing: auto-detects countries containing points min_points Minimum number points capture AoE. function finds smallest scale includes least many points. max_area Maximum halo area proportion original support area. Default 2, meaning halo area exceed twice support area (total AoE <= 3x original). Set Inf disable. max_dist Maximum expansion distance CRS units. buffer method, maximum buffer distance. stamp method, converted maximum scale based support's characteristic radius. Default NULL (distance cap). method Method computing area effect: \"buffer\" (default): Uniform buffer around support boundary. Robust polygon shape. Buffer distance calculated achieve target halo area. \"stamp\": Scale vertices outward centroid (reference point). Preserves shape proportions guarantees containment star-shaped polygons. May leave small gaps highly concave shapes. reference Optional sf object single POINT geometry. NULL (default), centroid support used. valid support single row method = \"stamp\". mask Optional mask clipping area effect. Can : sf object POLYGON MULTIPOLYGON geometry \"land\": use bundled global land mask exclude sea areas provided, area effect intersected mask. coords Column names coordinates points data.frame, e.g. c(\"lon\", \"lat\"). NULL, auto-detects common names.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_expand.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adaptive AoE Expansion to Capture Minimum Points — aoe_expand","text":"aoe_result object (aoe()) additional attributes: target_reached Logical: min_points achieved supports? Use attr(result, \"expansion_info\") per-support details. expansion_info Data frame per-support expansion details: support_id, scale_used, points_captured, target_reached, cap_hit.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_expand.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adaptive AoE Expansion to Capture Minimum Points — aoe_expand","text":"Unlike aoe(), applies consistent geometry across supports, aoe_expand() adapts scale per-support based local point density. Use caution: can make AoEs incomparable across regions different point densities.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_expand.html","id":"algorithm","dir":"Reference","previous_headings":"","what":"Algorithm","title":"Adaptive AoE Expansion to Capture Minimum Points — aoe_expand","text":"support, binary search finds minimum scale point count >= min_points. search bounded : Lower: scale = 0 (core ) Upper: minimum max_area cap max_dist cap caps prevent reaching min_points, warning issued result uses maximum allowed scale.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_expand.html","id":"caps","dir":"Reference","previous_headings":"","what":"Caps","title":"Adaptive AoE Expansion to Capture Minimum Points — aoe_expand","text":"Two caps ensure AoE expand unreasonably: max_area (relative): Limits halo area max_area times original. corresponding scale sqrt(1 + max_area) - 1. Default max_area = 2 means scale <= 0.732 (total area <= 3x). max_dist (absolute): Limits expansion distance CRS units. buffer method, buffer distance directly. stamp method, converted scale via max_dist / characteristic_radius characteristic_radius = sqrt(area / pi).","code":""},{"path":[]},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_expand.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adaptive AoE Expansion to Capture Minimum Points — aoe_expand","text":"","code":"library(sf)  # Create a support with sparse points support <- st_as_sf(   data.frame(id = 1),   geometry = st_sfc(st_polygon(list(     cbind(c(0, 100, 100, 0, 0), c(0, 0, 100, 100, 0))   ))),   crs = 32631 )  # Points scattered around set.seed(42) pts <- st_as_sf(   data.frame(id = 1:50),   geometry = st_sfc(lapply(1:50, function(i) {     st_point(c(runif(1, -50, 150), runif(1, -50, 150)))   })),   crs = 32631 )  # Expand until we have at least 20 points result <- aoe_expand(pts, support, min_points = 20)  # Check expansion info attr(result, \"expansion_info\")"},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_geometry.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract AoE Geometries — aoe_geometry","title":"Extract AoE Geometries — aoe_geometry","text":"Extract original support polygons /area effect polygons aoe_result object.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_geometry.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract AoE Geometries — aoe_geometry","text":"","code":"aoe_geometry(x, which = c(\"aoe\", \"original\", \"both\"), support_id = NULL)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_geometry.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract AoE Geometries — aoe_geometry","text":"x aoe_result object returned aoe(). geometry extract: \"aoe\" (default), \"original\", \"\". support_id Optional character numeric vector specifying support(s) extract. NULL (default), extracts .","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_geometry.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract AoE Geometries — aoe_geometry","text":"sf object polygon geometries columns: support_id Support identifier type \"original\" \"aoe\"","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_geometry.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract AoE Geometries — aoe_geometry","text":"","code":"library(sf)  support <- st_as_sf(   data.frame(region = c(\"A\", \"B\")),   geometry = st_sfc(     st_polygon(list(cbind(c(0, 10, 10, 0, 0), c(0, 0, 10, 10, 0)))),     st_polygon(list(cbind(c(15, 25, 25, 15, 15), c(0, 0, 10, 10, 0))))   ),   crs = 32631 )  pts <- st_as_sf(   data.frame(id = 1:4),   geometry = st_sfc(     st_point(c(5, 5)),     st_point(c(12, 5)),     st_point(c(20, 5)),     st_point(c(27, 5))   ),   crs = 32631 )  result <- aoe(pts, support)  # Get AoE polygons aoe_polys <- aoe_geometry(result, \"aoe\")  # Get both original and AoE for comparison both <- aoe_geometry(result, \"both\")  # Filter to one support (uses row names as support_id) region_1 <- aoe_geometry(result, \"aoe\", support_id = \"1\")"},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_sample.aoe_border_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Stratified Sampling from Border AoE Results — aoe_sample.aoe_border_result","title":"Stratified Sampling from Border AoE Results — aoe_sample.aoe_border_result","text":"Sample points aoe_border_result control side /core/halo balance.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_sample.aoe_border_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stratified Sampling from Border AoE Results — aoe_sample.aoe_border_result","text":"","code":"# S3 method for class 'aoe_border_result' aoe_sample(   x,   n = NULL,   ratio = NULL,   by = c(\"side\", \"class\"),   replace = FALSE,   ... )"},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_sample.aoe_border_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stratified Sampling from Border AoE Results — aoe_sample.aoe_border_result","text":"x aoe_border_result object returned aoe_border(). n Total number points sample. NULL, uses available points subject ratio constraint. ratio Named numeric vector specifying target proportions. Names match side names used aoe_border() (e.g., c(side_1 = 0.5, side_2 = 0.5)) use c(core = 0.5, halo = 0.5) distance-based sampling. Must sum 1. Character. stratify : \"side\" (default): sample side border \"class\": sample core/halo classification replace Logical. Sample replacement? Default FALSE. ... Additional arguments (ignored).","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_sample.aoe_border_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stratified Sampling from Border AoE Results — aoe_sample.aoe_border_result","text":"aoe_border_result object containing sampled points.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_sample.aoe_border_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stratified Sampling from Border AoE Results — aoe_sample.aoe_border_result","text":"","code":"library(sf)  # Create a border line border <- st_as_sf(   data.frame(id = 1),   geometry = st_sfc(st_linestring(matrix(     c(0, 0, 100, 100), ncol = 2, byrow = TRUE   ))),   crs = 32631 )  # Create points pts <- st_as_sf(   data.frame(id = 1:6),   geometry = st_sfc(     st_point(c(10, 20)),     st_point(c(30, 10)),     st_point(c(50, 80)),     st_point(c(80, 40)),     st_point(c(5, 5)),     st_point(c(95, 95))   ),   crs = 32631 )  result <- aoe_border(pts, border, width = 20,                      side_names = c(\"west\", \"east\"))  # Equal sampling from each side balanced <- aoe_sample(result, ratio = c(west = 0.5, east = 0.5))  # Sample by core/halo instead by_class <- aoe_sample(result, ratio = c(core = 0.5, halo = 0.5),                        by = \"class\")"},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_sample.html","id":null,"dir":"Reference","previous_headings":"","what":"Stratified Sampling from AoE Results — aoe_sample","title":"Stratified Sampling from AoE Results — aoe_sample","text":"Sample points aoe_result control core/halo balance. useful core regions dominate due point density, want balanced representation modelling.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stratified Sampling from AoE Results — aoe_sample","text":"","code":"aoe_sample(x, ...)  # Default S3 method aoe_sample(x, ...)  # S3 method for class 'aoe_result' aoe_sample(   x,   n = NULL,   ratio = c(core = 0.5, halo = 0.5),   replace = FALSE,   by = c(\"overall\", \"support\"),   ... )"},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stratified Sampling from AoE Results — aoe_sample","text":"x aoe_result object returned aoe() aoe_expand(). ... Additional arguments passed methods. n Total number points sample. NULL, uses available points subject ratio constraint (.e., downsamples larger group). ratio Named numeric vector specifying target proportion core halo points. Must sum 1. Default c(core = 0.5, halo = 0.5) equal representation. replace Logical. Sample replacement? Default FALSE. FALSE n exceeds available points stratum, stratum contributes points. Character. Stratification grouping: \"overall\" (default): sample points regardless support \"support\": apply ratio within support separately","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stratified Sampling from AoE Results — aoe_sample","text":"aoe_result object containing sampled points, preserving original columns attributes. additional attribute sample_info details sampling.","code":""},{"path":[]},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_sample.html","id":"sampling-modes","dir":"Reference","previous_headings":"","what":"Sampling modes","title":"Stratified Sampling from AoE Results — aoe_sample","text":"Fixed n: n specified, function samples exactly n points (fewer enough available), distributed according ratio. Balanced downsampling: n NULL, function downsamples larger stratum match smaller one according ratio. example, ratio c(core = 0.5, halo = 0.5) 100 core + 20 halo points, returns 20 core + 20 halo = 40 points.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_sample.html","id":"multiple-supports","dir":"Reference","previous_headings":"","what":"Multiple supports","title":"Stratified Sampling from AoE Results — aoe_sample","text":"= \"support\", sampling done independently within support, results combined. ensures support contributes balanced samples. = \"overall\", points pooled first.","code":""},{"path":[]},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_sample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stratified Sampling from AoE Results — aoe_sample","text":"","code":"library(sf)  support <- st_as_sf(   data.frame(id = 1),   geometry = st_sfc(st_polygon(list(     cbind(c(0, 100, 100, 0, 0), c(0, 0, 100, 100, 0))   ))),   crs = 32631 )  # Many points in core, few in halo set.seed(42) pts <- st_as_sf(   data.frame(id = 1:60),   geometry = st_sfc(c(     lapply(1:50, function(i) st_point(c(runif(1, 10, 90), runif(1, 10, 90)))),     lapply(1:10, function(i) st_point(c(runif(1, 110, 140), runif(1, 10, 90))))   )),   crs = 32631 )  result <- aoe(pts, support, scale = 1)  # Balance core/halo (downsamples core to match halo) balanced <- aoe_sample(result)  # Fixed sample size with 70/30 split sampled <- aoe_sample(result, n = 20, ratio = c(core = 0.7, halo = 0.3))"},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize Area of Effect Results — aoe_summary","title":"Summarize Area of Effect Results — aoe_summary","text":"Compute summary statistics AoE classification result, including counts proportions core vs halo points per support.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize Area of Effect Results — aoe_summary","text":"","code":"aoe_summary(x)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize Area of Effect Results — aoe_summary","text":"x sf object returned aoe().","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize Area of Effect Results — aoe_summary","text":"data frame one row per support, containing: support_id Support identifier n_total Total number supported points n_core Number core points n_halo Number halo points prop_core Proportion points core prop_halo Proportion points halo","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/aoe_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize Area of Effect Results — aoe_summary","text":"","code":"library(sf)  support <- st_as_sf(   data.frame(id = 1),   geometry = st_sfc(st_polygon(list(     cbind(c(0, 10, 10, 0, 0), c(0, 0, 10, 10, 0))   ))),   crs = 32631 )  pts <- st_as_sf(   data.frame(id = 1:4),   geometry = st_sfc(     st_point(c(5, 5)),     st_point(c(2, 2)),     st_point(c(15, 5)),     st_point(c(12, 5))   ),   crs = 32631 )  result <- aoe(pts, support) aoe_summary(result)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/bbox_to_polygon.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert bbox to polygon — bbox_to_polygon","title":"Convert bbox to polygon — bbox_to_polygon","text":"Convert bbox polygon","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/bbox_to_polygon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert bbox to polygon — bbox_to_polygon","text":"","code":"bbox_to_polygon(bbox, crs)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/bbox_to_polygon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert bbox to polygon — bbox_to_polygon","text":"bbox Bounding box (sf, sfc, named vector) crs CRS use","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/bbox_to_polygon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert bbox to polygon — bbox_to_polygon","text":"sfc polygon","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/countries.html","id":null,"dir":"Reference","previous_headings":"","what":"World Country Polygons with Pre-calculated AoE Bounds — countries","title":"World Country Polygons with Pre-calculated AoE Bounds — countries","text":"sf object containing country polygons Natural Earth (1:50m scale) pre-calculated bounding boxes area effect analysis.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/countries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"World Country Polygons with Pre-calculated AoE Bounds — countries","text":"","code":"countries"},{"path":"https://gcol33.github.io/areaOfEffect/reference/countries.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"World Country Polygons with Pre-calculated AoE Bounds — countries","text":"sf data frame 237 rows 9 variables: iso2 ISO 3166-1 alpha-2 country code (e.g., \"FR\", \"\") iso3 ISO 3166-1 alpha-3 country code (e.g., \"FRA\", \"BEL\") name Country name continent Continent name bbox Original bounding box (xmin, ymin, xmax, ymax) Mollweide bbox_equal_area AoE bounding box scale sqrt(2)-1 (equal areas) bbox_equal_ray AoE bounding box scale 1 (equal linear distance) halo_equal_area_scale Scale factor produces halo area = country area (land mask) geometry Country polygon WGS84 (EPSG:4326)","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/countries.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"World Country Polygons with Pre-calculated AoE Bounds — countries","text":"Natural Earth https://www.naturalearthdata.com/","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/countries.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"World Country Polygons with Pre-calculated AoE Bounds — countries","text":"","code":"# Get France france <- countries[countries$iso3 == \"FRA\", ]  # Use directly with aoe()"},{"path":"https://gcol33.github.io/areaOfEffect/reference/country_halos.html","id":null,"dir":"Reference","previous_headings":"","what":"Pre-computed Equal-Area Country Halos — country_halos","title":"Pre-computed Equal-Area Country Halos — country_halos","text":"named list pre-computed halo geometries country halo area equals country area (area proportion = 1). halos account land masking (sea areas excluded).","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/country_halos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pre-computed Equal-Area Country Halos — country_halos","text":"","code":"country_halos"},{"path":"https://gcol33.github.io/areaOfEffect/reference/country_halos.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Pre-computed Equal-Area Country Halos — country_halos","text":"named list ISO3 country codes names. element either sfc geometry (POLYGON MULTIPOLYGON) WGS84, NULL computation failed country.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/country_halos.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Pre-computed Equal-Area Country Halos — country_halos","text":"Computed Natural Earth country polygons land mask.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/country_halos.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pre-computed Equal-Area Country Halos — country_halos","text":"halo \"donut\" shape: area original country boundary expanded boundary, clipped land.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/country_halos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pre-computed Equal-Area Country Halos — country_halos","text":"","code":"# Get France's equal-area halo france_halo <- country_halos[[\"FRA\"]]"},{"path":"https://gcol33.github.io/areaOfEffect/reference/determine_sides.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine which side of a line each point is on — determine_sides","title":"Determine which side of a line each point is on — determine_sides","text":"Determine side line point ","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/determine_sides.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine which side of a line each point is on — determine_sides","text":"","code":"determine_sides(points, line)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/determine_sides.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine which side of a line each point is on — determine_sides","text":"points Points classify line Line geometry","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/determine_sides.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine which side of a line each point is on — determine_sides","text":"Vector side assignments (1 2)","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/find_border_width.html","id":null,"dir":"Reference","previous_headings":"","what":"Find buffer width that produces target area per side — find_border_width","title":"Find buffer width that produces target area per side — find_border_width","text":"Find buffer width produces target area per side","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/find_border_width.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find buffer width that produces target area per side — find_border_width","text":"","code":"find_border_width(border_geom, target_area, mask_geom, crs)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/find_border_width.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find buffer width that produces target area per side — find_border_width","text":"border_geom Border line geometry (sfc) target_area Target area side mask_geom Optional mask geometry crs CRS geometries","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/find_border_width.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find buffer width that produces target area per side — find_border_width","text":"Buffer width","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/find_halo_width.html","id":null,"dir":"Reference","previous_headings":"","what":"Find additional halo width for target halo area — find_halo_width","title":"Find additional halo width for target halo area — find_halo_width","text":"Find additional halo width target halo area","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/find_halo_width.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find additional halo width for target halo area — find_halo_width","text":"","code":"find_halo_width(border_geom, core_width, target_halo_area, mask_geom, crs)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/find_halo_width.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find additional halo width for target halo area — find_halo_width","text":"border_geom Border line geometry core_width Width core zone target_halo_area Target area halo per side mask_geom Optional mask geometry crs CRS","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/find_halo_width.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find additional halo width for target halo area — find_halo_width","text":"Additional width halo","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/get_country.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Country Polygon by Name or ISO Code — get_country","title":"Get Country Polygon by Name or ISO Code — get_country","text":"Quick accessor country polygons bundled dataset.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/get_country.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Country Polygon by Name or ISO Code — get_country","text":"","code":"get_country(x)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/get_country.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Country Polygon by Name or ISO Code — get_country","text":"x Country name, ISO2 code, ISO3 code (case-insensitive)","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/get_country.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Country Polygon by Name or ISO Code — get_country","text":"sf object country polygon, error found.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/get_country.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Country Polygon by Name or ISO Code — get_country","text":"","code":"get_country(\"Belgium\") get_country(\"BE\") get_country(\"BEL\")"},{"path":"https://gcol33.github.io/areaOfEffect/reference/land.html","id":null,"dir":"Reference","previous_headings":"","what":"Global Land Mask — land","title":"Global Land Mask — land","text":"sf object containing global land polygon Natural Earth (1:50m scale). Used masking area effect computations exclude ocean areas.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/land.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Global Land Mask — land","text":"","code":"land"},{"path":"https://gcol33.github.io/areaOfEffect/reference/land.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Global Land Mask — land","text":"sf data frame 1 row: name Description (\"Global Land\") geometry Land multipolygon WGS84 (EPSG:4326)","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/land.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Global Land Mask — land","text":"Natural Earth https://www.naturalearthdata.com/","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/land.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Global Land Mask — land","text":"","code":"# Use as mask to exclude sea # \\donttest{ dummy <- sf::st_as_sf(   data.frame(id = 1),   geometry = sf::st_sfc(sf::st_point(c(14.5, 47.5))),   crs = 4326 ) result <- aoe(dummy, \"AT\", mask = land) # }"},{"path":"https://gcol33.github.io/areaOfEffect/reference/plot.aoe_border_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for aoe_border_result — plot.aoe_border_result","title":"Plot method for aoe_border_result — plot.aoe_border_result","text":"Plot method aoe_border_result","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/plot.aoe_border_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for aoe_border_result — plot.aoe_border_result","text":"","code":"# S3 method for class 'aoe_border_result' plot(x, ...)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/plot.aoe_border_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for aoe_border_result — plot.aoe_border_result","text":"x aoe_border_result object ... Additional arguments passed plot","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/plot.aoe_border_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for aoe_border_result — plot.aoe_border_result","text":"NULL (called side effect)","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/plot.aoe_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for aoe_result — plot.aoe_result","title":"Plot method for aoe_result — plot.aoe_result","text":"Visualize AoE classification result, showing points colored class optionally support AoE boundaries.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/plot.aoe_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for aoe_result — plot.aoe_result","text":"","code":"# S3 method for class 'aoe_result' plot(   x,   support_id = NULL,   show_aoe = TRUE,   show_original = TRUE,   col_core = \"#2E7D32\",   col_halo = \"#F57C00\",   col_original = \"#000000\",   col_aoe = \"#9E9E9E\",   pch = 16,   cex = 0.8,   main = NULL,   ... )"},{"path":"https://gcol33.github.io/areaOfEffect/reference/plot.aoe_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for aoe_result — plot.aoe_result","text":"x aoe_result object support_id Optional: filter specific support(s) show_aoe Logical; show AoE boundary (default TRUE) show_original Logical; show original support boundary (default TRUE) col_core Color core points (default \"#2E7D32\", green) col_halo Color halo points (default \"#F57C00\", orange) col_original Color original support boundary (default \"#000000\") col_aoe Color AoE boundary (default \"#9E9E9E\") pch Point character (default 16) cex Point size (default 0.8) main Plot title (default auto-generated) ... Additional arguments passed plot","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/plot.aoe_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for aoe_result — plot.aoe_result","text":"Invisibly returns x","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/plot.aoe_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot method for aoe_result — plot.aoe_result","text":"","code":"library(sf)  support <- st_as_sf(   data.frame(id = 1),   geometry = st_sfc(st_polygon(list(     cbind(c(0, 10, 10, 0, 0), c(0, 0, 10, 10, 0))   ))),   crs = 32631 )  set.seed(42) pts <- st_as_sf(   data.frame(id = 1:50),   geometry = st_sfc(lapply(1:50, function(i) {     st_point(c(runif(1, -5, 15), runif(1, -5, 15)))   })),   crs = 32631 )  result <- aoe(pts, support) plot(result)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_area_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for aoe_area_result — print.aoe_area_result","title":"Print method for aoe_area_result — print.aoe_area_result","text":"Print method aoe_area_result","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_area_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for aoe_area_result — print.aoe_area_result","text":"","code":"# S3 method for class 'aoe_area_result' print(x, ...)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_area_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for aoe_area_result — print.aoe_area_result","text":"x aoe_area_result object ... Additional arguments (ignored)","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_area_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for aoe_area_result — print.aoe_area_result","text":"Invisibly returns x","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_border_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for aoe_border_result — print.aoe_border_result","title":"Print method for aoe_border_result — print.aoe_border_result","text":"Print method aoe_border_result","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_border_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for aoe_border_result — print.aoe_border_result","text":"","code":"# S3 method for class 'aoe_border_result' print(x, ...)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_border_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for aoe_border_result — print.aoe_border_result","text":"x aoe_border_result object ... Additional arguments (ignored)","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_border_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for aoe_border_result — print.aoe_border_result","text":"Invisibly returns x","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_expand_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for aoe_expand_result — print.aoe_expand_result","title":"Print method for aoe_expand_result — print.aoe_expand_result","text":"Print method aoe_expand_result","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_expand_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for aoe_expand_result — print.aoe_expand_result","text":"","code":"# S3 method for class 'aoe_expand_result' print(x, ...)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_expand_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for aoe_expand_result — print.aoe_expand_result","text":"x aoe_expand_result object ... Additional arguments (ignored)","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_expand_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for aoe_expand_result — print.aoe_expand_result","text":"Invisibly returns x","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for aoe_result — print.aoe_result","title":"Print method for aoe_result — print.aoe_result","text":"Print method aoe_result","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for aoe_result — print.aoe_result","text":"","code":"# S3 method for class 'aoe_result' print(x, ...)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for aoe_result — print.aoe_result","text":"x aoe_result object ... Additional arguments passed print.sf","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for aoe_result — print.aoe_result","text":"Invisibly returns x","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_summary_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for aoe_summary_result — print.aoe_summary_result","title":"Print method for aoe_summary_result — print.aoe_summary_result","text":"Print method aoe_summary_result","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_summary_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for aoe_summary_result — print.aoe_summary_result","text":"","code":"# S3 method for class 'aoe_summary_result' print(x, ...)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_summary_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for aoe_summary_result — print.aoe_summary_result","text":"x aoe_summary_result object ... Additional arguments (ignored)","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/print.aoe_summary_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for aoe_summary_result — print.aoe_summary_result","text":"Invisibly returns x","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/split_by_buffer.html","id":null,"dir":"Reference","previous_headings":"","what":"Split polygon using buffer method (fallback) — split_by_buffer","title":"Split polygon using buffer method (fallback) — split_by_buffer","text":"Split polygon using buffer method (fallback)","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/split_by_buffer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split polygon using buffer method (fallback) — split_by_buffer","text":"","code":"split_by_buffer(polygon, line, crs)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/split_by_buffer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split polygon using buffer method (fallback) — split_by_buffer","text":"polygon Polygon split line Line split crs CRS","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/split_by_buffer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split polygon using buffer method (fallback) — split_by_buffer","text":"List side1 side2","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/split_by_line.html","id":null,"dir":"Reference","previous_headings":"","what":"Split a polygon by a line into two sides — split_by_line","title":"Split a polygon by a line into two sides — split_by_line","text":"Split polygon line two sides","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/split_by_line.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split a polygon by a line into two sides — split_by_line","text":"","code":"split_by_line(polygon, line, crs)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/split_by_line.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split a polygon by a line into two sides — split_by_line","text":"polygon Polygon geometry split line Line geometry split crs CRS","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/split_by_line.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split a polygon by a line into two sides — split_by_line","text":"List side1 side2 geometries","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/sub-.aoe_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset method for aoe_result — [.aoe_result","title":"Subset method for aoe_result — [.aoe_result","text":"Preserves aoe_result attributes subsetting.","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/sub-.aoe_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset method for aoe_result — [.aoe_result","text":"","code":"# S3 method for class 'aoe_result' x[i, ...]"},{"path":"https://gcol33.github.io/areaOfEffect/reference/sub-.aoe_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset method for aoe_result — [.aoe_result","text":"x aoe_result object Row indices ... Additional arguments passed sf subsetting","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/sub-.aoe_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset method for aoe_result — [.aoe_result","text":"aoe_result object (sf support_id removed)","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/summary.aoe_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for aoe_result — summary.aoe_result","title":"Summary method for aoe_result — summary.aoe_result","text":"Summary method aoe_result","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/summary.aoe_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for aoe_result — summary.aoe_result","text":"","code":"# S3 method for class 'aoe_result' summary(object, ...)"},{"path":"https://gcol33.github.io/areaOfEffect/reference/summary.aoe_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for aoe_result — summary.aoe_result","text":"object aoe_result object ... Additional arguments (ignored)","code":""},{"path":"https://gcol33.github.io/areaOfEffect/reference/summary.aoe_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for aoe_result — summary.aoe_result","text":"aoe_summary_result object","code":""},{"path":"https://gcol33.github.io/areaOfEffect/news/index.html","id":"areaofeffect-025","dir":"Changelog","previous_headings":"","what":"areaOfEffect 0.2.5","title":"areaOfEffect 0.2.5","text":"Reposition package general spatial classification tool (ecology-specific) Updated README Statement Need section clearer feature descriptions Updated DESCRIPTION title description domain-agnostic Added CRAN badges installation instructions","code":""},{"path":"https://gcol33.github.io/areaOfEffect/news/index.html","id":"areaofeffect-024","dir":"Changelog","previous_headings":"","what":"areaOfEffect 0.2.4","title":"areaOfEffect 0.2.4","text":"CRAN release: 2026-02-06 Fixed \\dontrun{} aoe_sample.aoe_border_result example - replaced complete, self-contained example runs < 5 seconds (CRAN policy compliance)","code":""},{"path":"https://gcol33.github.io/areaOfEffect/news/index.html","id":"areaofeffect-010","dir":"Changelog","previous_headings":"","what":"areaOfEffect 0.1.0","title":"areaOfEffect 0.1.0","text":"Initial CRAN release. ## Core Functionality aoe() classifies points “core” (inside support) “halo” (inside scaled area effect outside original support), pruning points outside Default scale sqrt(2) - 1 produces equal core halo areas - geometrically derived default requiring parameter tuning Multiple supports processed independently long format output Optional mask argument hard boundaries (coastlines, etc.)","code":""},{"path":"https://gcol33.github.io/areaOfEffect/news/index.html","id":"s3-class-system-0-1-0","dir":"Changelog","previous_headings":"","what":"S3 Class System","title":"areaOfEffect 0.1.0","text":"aoe_result class extending sf specialized methods print() method showing point counts, supports, scale info summary() method returning area statistics plot() method visualizing points support/AoE boundaries","code":""},{"path":"https://gcol33.github.io/areaOfEffect/news/index.html","id":"helper-functions-0-1-0","dir":"Changelog","previous_headings":"","what":"Helper Functions","title":"areaOfEffect 0.1.0","text":"aoe_summary() counts proportions per support aoe_geometry() extract original AoE polygon geometries aoe_area() area statistics including halo:core ratio masking effects","code":""}]
